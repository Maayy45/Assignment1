# -*- coding: utf-8 -*-
"""MayurIBM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19x85Ltx74RPV8wNl_q40bbq7vklymiNj

**Practice class 1**
"""

#creating a variable
a=5
print(a)

print("hello")
# string ie, words always require double or single coats.

#string
a="hello"
print(a)
print(type(a))

#integer
b=345
print(b)
print(type(b))

#float
c=13.65
print(c)
print(type(c))

#boolean
d=9>10
print(d)
print(type(d))

#maths
num1=36.5
num2=2
sum=num1+num2
diff=num1-num2
mul=num1*num2
div=num1/num2
print(round(sum))
print(diff)
print(mul)
print(div)

print("the addition of two numbers are",sum)
print("the difference of two numbers are",diff)
print("the product of two numbers are",mul)
print("the quotient of two numbers are",div)

#in the first by putting round decimal will get round off to closest place.

#concatenationn
num1=(input("enter first number"))
num2=(input("enter second number"))
print("sum of two numbers are",num1+num2)

num3=int(input("enter third number"))
num4=int(input("enter fourth number"))
print("sum of two numbers are",num3+num4)

#concatenate means just joining,but in second by putting type ie,int we get sum

name1=("tom and jerry")
print("my favourite cartoon is "+name1)
print("my favourite cartoon is",name1)

#both gives same result

"""**Practice class 2- collection of data types.**"""

# 1. list[]  2.tuple()  3.Dictionary{}  4.set{}

#1. list- ordered collection of datatypes []
# homogeneous meaning same dataypes - list1
# heterogeneous meanig=ng different datatypes - list2

list1=[1,2,3,4]
print(list1)
print(type(list1))

list2=[2,34.05,"data",True]
print(list2)
print(type(list2))

#indexing or index number helps to print data induvidually.
list3=[23,45.1,False,"data",82]
print(list3[0])
print(list3[-1])
print(list3[2])

a="index number"
print(a[5])
print(a[-1])
print(a.index("d"))

#in the first one number 5 is a space thats why nothing given.

#mutable- data can be changed or updated.
list3=[23,45.1,False,"data",82]
print(list3)
list3[3]=True
print(list3)
print("the updated values are",list3)

# append or show additional data
list3.append(41)
print("the updated list is",list3)

# extend to add multiple data at once
b=[3,"moredata",34.2]
list3.extend(b)
print("the extended values are",list3)

# insert data at specific places (uses indexing)
list3.insert(2,"hello")
print("the list with inserted value is",list3)

# to delete data
del list3[1]
print("the list after deleting is",list3)

# remove data works like delete but dont need to use index numbers
list3.remove("moredata")
print("the list after removing is",list3)

"""
**Practice class 3**"""

#2. tuple-ordered collection of data ()
#immutable or not changeable

tuple=("data",False,34.05,7)
tuple[2]=24
print(tuple)

tuple.append(3)
print(tuple)

tuple.remove(34.05)
print(tuple)

#finding length and class
tuple=("data",False,34.05,7)
print(tuple)
print(len(tuple))
print(type(tuple))

#by doing del tuple and print(tuple) it will show tuple not defined

#3. Dictionary 
#key pair (key and values)
dict={ "Brand" : "HP",
       "Color" : "Silver",
       "Year_of_Buying" : 2022
}
print(dict)

#update data possible
dict["Brand"]="Asus"
print(dict)

#can even add without append
dict["Model"]="Latest"
print(dict)

#can  delete elements
del dict["Model"]
print(dict)

#concatenate data
dict["Brand"]="Asus"+"ROG"
print(dict)

#print specific data using key
print(dict["Color"])

#list + dict

list1=["webdevelopment","Datascience"]
dict1={"course" : "Python"
}
print(dict1)
dict1["course"]=list1
print(dict1)

#merging two dictionaries
dict2={"class" : 11
       }
dict3={"class" : 12
       }
dict2["class"]=dict3
print(dict2)

"""**Class 4 - Set and Github**"""

#set - unordered collection of datatypes , {}, doesnt contain duplicate values,mutable
set={1,"set",False,34.55,1}
print(set)
#add data
set.add(45)
print(set)

#append and indexing all wont work
set1={45,"index",True,78.23}
print(set1)
print(set1[1])

set1.append("data")
print(set1)

a=[23,"hello",45.56]
set1.extend(a)
print(set1)

#frozen set- cant add anything else
frzset=frozenset(["HP","Windows"])
print(frzset)
frzset.add("Asus")
print(frzset)

#combining datas or union
set1={1,24,567,1,23}
set2={49,"data",45.7,21,1}
set3=set1.union(set2)
print("the final values are",set3)
#set 3 can aslo be written like set1/(set2)

#intersection means common data
set1={1,23,4,56,4}
set2={2,"data",32,325,4,5647}
set4=set1.intersection(set2)
print(set4)
#can even write set1&(set2)

#set5=set1.difference(set2)
#print(set5)

#Function- set of code/instruction will be executed whenever you call a function.
print("hello all")
print("welcome all")
print("hello all")
print("welcome all")
#to print data many times we have to keep entering data but function makes it easy

def details(name):
  print("my favourite cartoon is",name)
details("tom")

def a():
  for x in range(10):
    print(x)
a()

def b():
  for x in range(5):
    print("hello all")
    print("welcome all")
b()

def add(num1,num2):
  print("the addition of two numbers are",(num1+num2))
add(100,24)

def sub(num3,num4):
  print("the difference of two numbers are",(num3-num4))
sub(50,30)

def product(num5,num6):
  print("the product of two numbers are",(num5*num6))
product(20,30)

def quotient(num7,num8):
  print("the quotient of two numbers are",(num7/num8))
quotient(500,10)

"""**Class 4-more in functions**"""

def a():
  x=range(6)
  for n in x:
    print("the values are",(n+1))
a()

#iteration- helps print data one by one
list1=[23,5,True,45,1,"hello",75.4,62]
iteration=iter(list1)
print(next(iteration))

print(next(iteration))
#so after putting this in the new code and keep pressing play next numbers will be coming.

#for loop- helps print data one by one
list1=[23,4,56.7,"as",True,55]
for x in list1:
  print(x)

name="tom and jerry"
for x in name:
  print(x)

name="luffy and zoro"
a=iter(name)
print(next(a))

print(next(a))

def calc():
  x=range(5)
  y=50
  for n in x:
    print("the sum of two values are",(n+y))
calc()

def example():
  x=range(5)
  y=10
  for n in x:
    print("the product of two values are",(n*y))
example()

def add():
  b=int(input("enter first value"))
  c=int(input("enter second value"))
  print("sum of two values are",(b+c))
add()

def pro():
  for x in range(4):
    for y in range(5):
      print("product is",(x*y))
pro()

"""**class 6- files**
file - different types of modes
1. read mode(r)
2. write mode(w)
3. Append mode(a)
"""

file1=open("a.txt","r")
print(file1.read())

file1.close()

file1=open("a.txt","w")
file1.write("this is written by the user \n")
#the \n helps print data in new line.

file1=open("a.txt","r")
print(file1.read())

file1=open("a.txt","a")
file1.write("this is written by the programmer")

file1=open("a.txt","r")
print(file1.read())

anime=["One Piece \n","Naruto \n","Bleach"]
#context manager
with open("myanime.txt","a") as file2:
  file2.writelines(anime)

with open("myanime.txt","r") as file2:
  print(file2.read())

"""**what is r+** :
In R+ mode we can read a file as well as write additional to it 
which is not possible in only read.
"""

file3=open("example1.txt","r")
print(file3.read())

with open("example1.txt","r+") as A:
  A.read()
  A.write("this does not require use of append \n")

"""**what is w+** : In W+ mode we can write and read file the additional data too."""

file4=open("example2.txt","r")
print(file4.read())

with open("example2.txt","w+") as B:
  B.write("w only overwrites info\n")

"""**what is a+** : In A+ mode adds reading file to existing mode"""

file5=open("example3.txt","r")
print(file5.read())

with open("example3.txt","a+") as C:
  C.write("a only adds data\n")